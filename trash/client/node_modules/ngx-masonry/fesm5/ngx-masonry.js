import { __decorate, __metadata, __param } from 'tslib';
import { Input, Output, EventEmitter, Component, Inject, PLATFORM_ID, ElementRef, Directive, forwardRef, NgModule } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';

var imagesLoaded;
var masonryConstructor;
var NgxMasonryComponent = /** @class */ (function () {
    function NgxMasonryComponent(platformId, _element) {
        this.platformId = platformId;
        this._element = _element;
        this.useImagesLoaded = false;
        this.updateLayout = false;
        // Outputs
        this.layoutComplete = new EventEmitter();
        this.removeComplete = new EventEmitter();
    }
    NgxMasonryComponent.prototype.ngOnInit = function () {
        var _this = this;
        if (this.useImagesLoaded && imagesLoaded === undefined) {
            imagesLoaded = require('imagesloaded');
        }
        if (isPlatformBrowser(this.platformId) && masonryConstructor === undefined) {
            masonryConstructor = require('masonry-layout');
        }
        // Create masonry options object
        if (!this.options) {
            this.options = {};
        }
        // Set default itemSelector
        if (!this.options.itemSelector) {
            this.options.itemSelector = '[ngxMasonryItem], ngxMasonryItem';
        }
        if (isPlatformBrowser(this.platformId)) {
            // Initialize Masonry
            this._msnry = new masonryConstructor(this._element.nativeElement, this.options);
            // Bind to events
            this._msnry.on('layoutComplete', function (items) {
                _this.layoutComplete.emit(items);
            });
            this._msnry.on('removeComplete', function (items) {
                _this.removeComplete.emit(items);
            });
        }
    };
    NgxMasonryComponent.prototype.ngOnChanges = function (changes) {
        // only update layout if it's not the first change
        if (changes.updateLayout) {
            if (!changes.updateLayout.firstChange) {
                this.layout();
            }
        }
    };
    NgxMasonryComponent.prototype.ngOnDestroy = function () {
        if (this._msnry) {
            this._msnry.destroy();
        }
    };
    NgxMasonryComponent.prototype.layout = function () {
        var _this = this;
        setTimeout(function () {
            _this._msnry.layout();
        });
    };
    NgxMasonryComponent.prototype.reloadItems = function () {
        var _this = this;
        setTimeout(function () {
            _this._msnry.reloadItems();
        });
    };
    // public add(element: HTMLElement, prepend: boolean = false) {
    NgxMasonryComponent.prototype.add = function (element) {
        var _this = this;
        var isFirstItem = false;
        // Check if first item
        if (this._msnry.items.length === 0) {
            isFirstItem = true;
        }
        if (this.useImagesLoaded) {
            imagesLoaded(element, function (instance) {
                _this._element.nativeElement.appendChild(element);
                // Tell Masonry that a child element has been added
                _this._msnry.appended(element);
                // layout if first item
                if (isFirstItem) {
                    _this.layout();
                }
            });
            this._element.nativeElement.removeChild(element);
        }
        else {
            // Tell Masonry that a child element has been added
            this._msnry.appended(element);
            // layout if first item
            if (isFirstItem) {
                this.layout();
            }
        }
    };
    NgxMasonryComponent.prototype.remove = function (element) {
        // Tell Masonry that a child element has been removed
        this._msnry.remove(element);
        // Layout items
        this.layout();
    };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], NgxMasonryComponent.prototype, "options", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], NgxMasonryComponent.prototype, "useImagesLoaded", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], NgxMasonryComponent.prototype, "updateLayout", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], NgxMasonryComponent.prototype, "layoutComplete", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], NgxMasonryComponent.prototype, "removeComplete", void 0);
    NgxMasonryComponent = __decorate([
        Component({
            selector: '[ngx-masonry], ngx-masonry',
            template: '<ng-content></ng-content>',
            styles: ["\n\t\t:host {\n\t\t\tdisplay: block;\n\t\t}\n\t"]
        }),
        __param(0, Inject(PLATFORM_ID)),
        __metadata("design:paramtypes", [Object, ElementRef])
    ], NgxMasonryComponent);
    return NgxMasonryComponent;
}());

var NgxMasonryDirective = /** @class */ (function () {
    function NgxMasonryDirective(_element, _parent, platformId) {
        this._element = _element;
        this._parent = _parent;
        this.platformId = platformId;
    }
    NgxMasonryDirective.prototype.ngAfterViewInit = function () {
        if (isPlatformBrowser(this.platformId)) {
            this._parent.add(this._element.nativeElement);
            this.watchForHtmlChanges();
        }
    };
    NgxMasonryDirective.prototype.ngOnDestroy = function () {
        if (isPlatformBrowser(this.platformId)) {
            this._parent.remove(this._element.nativeElement);
        }
    };
    /** When HTML in brick changes dinamically, observe that and change layout */
    NgxMasonryDirective.prototype.watchForHtmlChanges = function () {
        MutationObserver = window.MutationObserver || window.WebKitMutationObserver;
        if (MutationObserver) {
            /** Watch for any changes to subtree */
            var self_1 = this;
            var observer = new MutationObserver(function (mutations, observerFromElement) {
                self_1._parent.layout();
            });
            // define what element should be observed by the observer
            // and what types of mutations trigger the callback
            observer.observe(this._element.nativeElement, {
                subtree: true,
                childList: true
            });
        }
    };
    NgxMasonryDirective = __decorate([
        Directive({
            selector: '[ngxMasonryItem], ngxMasonryItem'
        }),
        __param(1, Inject(forwardRef(function () { return NgxMasonryComponent; }))),
        __param(2, Inject(PLATFORM_ID)),
        __metadata("design:paramtypes", [ElementRef,
            NgxMasonryComponent, Object])
    ], NgxMasonryDirective);
    return NgxMasonryDirective;
}());

var NgxMasonryModule = /** @class */ (function () {
    function NgxMasonryModule() {
    }
    NgxMasonryModule = __decorate([
        NgModule({
            imports: [],
            declarations: [NgxMasonryComponent, NgxMasonryDirective],
            exports: [NgxMasonryComponent, NgxMasonryDirective]
        })
    ], NgxMasonryModule);
    return NgxMasonryModule;
}());

export { NgxMasonryComponent, NgxMasonryDirective, NgxMasonryModule };
//# sourceMappingURL=ngx-masonry.js.map
